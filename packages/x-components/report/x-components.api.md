## API Report File for "@empathy/x-components"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ActionContext } from 'vuex';
import { ComponentOptions } from 'vue';
import { Module } from 'vuex';
import { NextQueriesRequest } from '@empathy/search-adapter';
import { Observable } from 'rxjs/Observable';
import { SearchAdapter } from '@empathy/search-adapter';
import { Store } from 'vuex';
import { Subject } from 'rxjs/Subject';
import { Subscription } from 'rxjs/Subscription';
import { SuggestionsRequest } from '@empathy/search-adapter';
import Vue from 'vue';
import { Vue as Vue_2 } from 'vue-property-decorator';
import { VueConstructor } from 'vue';
import { WatchOptions } from 'vue';

// @public
export type ActionsClass<Module extends AnyXStoreModule> = Partial<Module['actions']>;

// @public
export type ActionsDictionary<Actions> = Record<keyof Actions, (payload?: any) => any>;

// @public
export type ActionsTree<State extends Dictionary, Getters extends Dictionary, Mutations extends MutationsDictionary<Mutations>, Actions extends ActionsDictionary<Actions>> = {
    [Key in keyof Actions]: (context: XActionContext<State, Getters, Mutations, Actions>, payload: ExtractPayload<Actions[Key]>) => ReturnType<Actions[Key]> | Promise<ReturnType<Actions[Key]>>;
};

// @public
export const addQueryToHistory: ({ state, dispatch }: HistoryQueriesActionContext, query: string) => void | Promise<void>;

// @public
export class AddQueryToHistoryAction implements ActionsClass<HistoryQueriesXStoreModule> {
    addQueryToHistory({ state, dispatch }: HistoryQueriesActionContext, query: string): void | Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "HistoryQuery" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected createHistoryQuery(query: string): HistoryQuery_2;
    // @internal
    protected createNewHistory(currentHistory: HistoryQuery_2[], normalizedQuery: string): HistoryQuery_2[] | null;
    // @internal
    protected isAddAction([lastWords, newWords]: Pair<string[]>, [lastQuery, newQuery]: Pair<string>): boolean;
    // @internal
    protected isLastWordRefined(lastWords: string[], newWords: string[]): boolean;
    // @internal
    protected isReplaceAction([lastWords, newWords]: Pair<string[]>, [lastQuery, newQuery]: Pair<string>): boolean;
    // @internal
    protected removeNewQueryFromHistory(currentHistory: HistoryQuery_2[], normalizedQuery: string): HistoryQuery_2[];
}

// @public
export const addQueryToHistoryQueries: import("../..").Wire<string>;

// @public
export type AnyActionsTree = ActionsTree<Dictionary, Dictionary, MutationsDictionary<any>, ActionsDictionary<any>>;

// @public
export type AnyFunction = (...args: any[]) => any;

// @public
export type AnyGettersTree = GettersTree<Dictionary, Dictionary>;

// @public
export type AnyMutationsTree = MutationsTree<Dictionary, MutationsDictionary<any>>;

// @public
export type AnySimpleStateSelector = SimpleStateSelector<any, any, any>;

// @public
export type AnyStateSelector = StateSelector<any, any, any>;

// @public
export type AnyStoreEmitters = StoreEmitters<AnyXStoreModule>;

// @public
export type AnyWire = Wire<any>;

// @public
export type AnyXModule = XModule<AnyXStoreModule>;

// @public
export type AnyXStoreModule = XStoreModule<any, any, any, any>;

// @public
export type AnyXStoreModuleOptions = XStoreModuleOptions<AnyXStoreModule>;

// @public
export type ArrowKey = 'ArrowUp' | 'ArrowDown' | 'ArrowRight' | 'ArrowLeft';

// @public
export class BaseXBus implements XBus {
    emit<Event extends XEvent>(event: Event, payload?: XEventPayload<Event>, metadata?: WireMetadata): void;
    // @internal
    protected emitters: Emitters;
    // @internal
    protected getOrCreateEmitter<Event extends XEvent>(event: Event): Emitter<Event>;
    on<Event extends XEvent>(event: Event, withMetadata?: boolean): Observable<WirePayload<XEventPayload<Event>> | XEventPayload<Event>>;
}

// @internal
export const bus: XBus;

// @public
export class ClearHistoryQueries extends Vue {
    // @internal
    protected clearHistoryQueriesEvents: Partial<XEventsTypes>;
    // @internal
    protected get dynamicClasses(): VueCSSClasses;
    // @internal
    historyQueries: HistoryQuery_2[];
    // @internal
    protected get isHistoryQueriesEmpty(): boolean;
}

// @public
export const clearHistoryQueries: import("../..").Wire<any>;

// @public
export const clearHistoryQueriesQuery: import("../..").Wire<any>;

// @public
export const clearQuerySuggestionsQuery: import("../..").Wire<any>;

// @public
export class ClearSearchInput extends Vue {
    // @internal
    protected clearSearchInputEvents: Partial<XEventsTypes>;
    // (undocumented)
    protected get dynamicClasses(): VueCSSClasses;
    // (undocumented)
    protected get isQueryEmpty(): boolean;
    // (undocumented)
    query: string;
}

// @public
export function createStoreEmitters<Module extends AnyXStoreModule, Emitters extends StoreEmitters<Module>>(storeModule: Module, emitters: Emitters): Emitters;

// @public
export function createWireFromFunction<Payload>(fn: (parameters: WireParams<Payload>) => void): Wire<Payload>;

// @public
export function createWiring<T extends Partial<Wiring>>(wiring: T): T;

// @internal
export const createXComponentAPIMixin: (config: XConfig) => ComponentOptions<Vue, import("vue/types/options").DefaultData<Vue>, import("vue/types/options").DefaultMethods<Vue>, import("vue/types/options").DefaultComputed, import("vue/types/options").PropsDefinition<Record<string, any>>, Record<string, any>> & ThisType<Vue & {
    xComponent: XComponent | undefined;
}>;

// @public
export interface CurrencyOptions {
    symbol: string;
}

// @public
export type DecoratorFor<Type> = <Key extends string, Target extends Record<Key, Type>>(target: Target, key: Key) => void;

// @public
export type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends Primitive ? T[P] : DeepPartial<T[P]>;
};

// @public
export const DEFAULT_X_CONFIG: XConfig;

// @public
export type Dictionary<T = any> = Record<string, T>;

// @public
export type DocumentDirection = 'ltr' | 'rtl';

// @public
export type Emitter<Event extends XEvent> = Subject<WirePayload<XEventPayload<Event>>>;

// @public
export type Emitters = {
    [Event in XEvent]?: Emitter<Event>;
};

// @public
export type ExtractActionReturn<Action extends (payload?: any) => any> = ReturnType<Action> extends Promise<any> ? ReturnType<Action> : Promise<ReturnType<Action>>;

// @public
export type ExtractActions<Module extends AnyXModule> = Module extends XModule<XStoreModule<any, any, any, infer Actions>> ? Actions : never;

// @public
export type ExtractGetters<Module extends XModuleName> = Returns<XModulesTree[Module]['storeModule']['getters']>;

// @public
export type ExtractMutations<Module extends AnyXModule> = Module extends XModule<XStoreModule<any, any, infer Mutations, any>> ? Mutations : never;

// @public
export type ExtractPayload<Function extends (payload?: any) => any> = Parameters<Function>[0];

// @public
export type ExtractState<Module extends XModuleName> = ReturnType<XModulesTree[Module]['storeModule']['state']>;

// @public
export function forEach<T extends Dictionary>(obj: T | undefined | null, callbackFn: (key: keyof T, value: Exclude<T[keyof T], undefined>, index: number) => void): void;

// @public
export const getAndSaveNextQueries: import("../..").Wire<any>;

// @public
export const getAndSaveSuggestions: import("../..").Wire<any>;

// @public
export function getRootXComponent(component: Vue): XComponent | undefined;

// @public
export function Getter<Module extends XModuleName, GetterName extends keyof ExtractGetters<Module>>(module: Module, getter: GetterName): DecoratorFor<ExtractGetters<Module>[GetterName]>;

// @public
export type GettersClass<Module extends AnyXStoreModule> = Partial<Module['getters']>;

// @public
export type GettersTree<State extends Dictionary, Getters extends Dictionary> = {
    [Key in keyof Getters]: (state: State, getters: Getters, rootState: RootXStoreState, rootGetters: any) => Getters[Key];
};

// @internal
export function getXComponentXModuleName(component: Vue): XModuleName | null;

// @public
export class HistoryQueries extends Vue {
    // @internal
    historyQueries: HistoryQuery_2[];
}

// @public
export const historyQueries: ({ query, historyQueries, config }: HistoryQueriesState) => HistoryQuery_2[];

// @public
export type HistoryQueriesActionContext = XActionContext<HistoryQueriesState, HistoryQueriesGetters, HistoryQueriesMutations, HistoryQueriesActions>;

// @public
export interface HistoryQueriesActions {
    addQueryToHistory(query: string): void;
    loadHistoryQueriesFromBrowserStorage(): void;
    refreshSession(): void;
    removeFromHistory(historyQuery: HistoryQuery_2): void;
    setHistoryQueries(historyQueries: HistoryQuery_2[]): void;
}

// @public
export interface HistoryQueriesConfig {
    debounceInMs: number;
    hideIfEqualsQuery: boolean;
    maxItemsToRender: number;
    maxItemsToStore: number;
    sessionTTLInMs: number;
}

// @internal
export const historyQueriesEmitters: {
    SessionHistoryQueriesChanged: (_state: import("./types").HistoryQueriesState, getters: import("../../..").Returns<import("../../../store").GettersTree<import("./types").HistoryQueriesState, import("./types").HistoryQueriesGetters>>) => import("@empathy/search-types").HistoryQuery[];
    HistoryQueriesQueryChanged: {
        immediate: true;
        selector: (state: import("./types").HistoryQueriesState) => string;
    };
    HistoryQueriesStorageKeyChanged: {
        immediate: true;
        selector: (_state: import("./types").HistoryQueriesState, getters: import("../../..").Returns<import("../../../store").GettersTree<import("./types").HistoryQueriesState, import("./types").HistoryQueriesGetters>>) => string;
    };
};

// @public
export class HistoryQueriesGetter implements GettersClass<HistoryQueriesXStoreModule> {
    historyQueries({ query, historyQueries, config }: HistoryQueriesState): HistoryQuery_2[];
    // @internal
    protected searchInHistoryQueries(normalizedQuery: string, hideIfEqualsQuery: boolean): (historyQuery: HistoryQuery_2) => boolean;
}

// @public
export interface HistoryQueriesGetters {
    historyQueries: HistoryQuery_2[];
    sessionHistoryQueries: HistoryQuery_2[];
    storageKey: string;
}

// @public
export interface HistoryQueriesMutations {
    setHistoryQueries(historyQueries: HistoryQuery_2[]): void;
    setQuery(query: string): void;
    setSessionTimeStamp(timeStamp: number): void;
}

// @public
export interface HistoryQueriesState {
    config: HistoryQueriesConfig;
    historyQueries: HistoryQuery_2[];
    query: string;
    sessionTimeStampInMs: number;
}

// @internal
export const historyQueriesWiring: {
    HistoryQueriesQueryChanged: {
        refreshHistoryQueriesSession: import("../..").Wire<any>;
    };
    HistoryQueriesStorageKeyChanged: {
        loadHistoryQueriesFromBrowserStorage: import("../..").Wire<any>;
    };
    UserPressedClearSearchBoxButton: {
        clearHistoryQueriesQuery: import("../..").Wire<any>;
    };
    UserAcceptedAQuery: {
        setHistoryQueriesQuery: import("../..").Wire<string>;
        addQueryToHistoryQueries: import("../..").Wire<string>;
    };
    UserIsTypingAQuery: {
        setHistoryQueriesQuery: import("../..").Wire<string>;
    };
    UserPressedClearHistoryQueries: {
        clearHistoryQueries: import("../..").Wire<any>;
    };
    UserPressedRemoveHistoryQuery: {
        removeHistoryQuery: import("../..").Wire<import("@empathy/search-types").HistoryQuery>;
    };
};

// @public
export type HistoryQueriesXModule = XModule<HistoryQueriesXStoreModule>;

// @public
export const historyQueriesXModule: HistoryQueriesXModule;

// @public
export type HistoryQueriesXStoreModule = XStoreModule<HistoryQueriesState, HistoryQueriesGetters, HistoryQueriesMutations, HistoryQueriesActions>;

// @internal
export let historyQueriesXStoreModule: HistoryQueriesXStoreModule;

// @public
export class HistoryQuery extends Vue {
    // @internal
    query: string;
    protected suggestion: HistoryQuery_2;
    // @internal
    protected get suggestionSelectedEvents(): Partial<XEventsTypes>;
}

// @public
export function isArrayEmpty(array: unknown[] | undefined | null): array is undefined | null | [];

// @public
export function isXComponent(component: Vue): component is XComponent;

// @public
export const loadHistoryQueriesFromBrowserStorage: import("../..").Wire<any>;

// @public
export function map<T extends Dictionary, W>(obj: T | undefined | null, mapper: (key: keyof T, value: Exclude<T[keyof T], undefined>, index: number) => W): Record<keyof T, W>;

// @public
export interface Message {
    // (undocumented)
    [key: string]: Message | string;
}

// @public
export interface Messages {
    // (undocumented)
    custom?: Message;
    // (undocumented)
    historyQueries: {
        clearButton: {
            content: string;
            ariaLabel: string;
        };
        removeHistoryQuery: {
            ariaLabel: string;
            content: string;
        };
    };
    // (undocumented)
    searchBox: {
        ariaLabel: string;
        placeholder: string;
        clearButton: {
            ariaLabel: string;
        };
        searchButton: {
            ariaLabel: string;
        };
    };
}

// @public
export type MutationsDictionary<Mutations> = Record<keyof Mutations, (payload?: any) => void>;

// @public
export type MutationsTree<State extends Dictionary, Mutations extends MutationsDictionary<Mutations>> = {
    [Key in keyof Mutations]: (state: State, payload: ExtractPayload<Mutations[Key]>) => void;
};

// @public
export interface NamespacedWireFactory<ModuleName extends XModuleName> {
    wireCommit<Mutations extends ExtractMutations<XModulesTree[ModuleName]>, MutationName extends PropsWithType<Mutations, (payload: any) => void>>(mutation: MutationName, payload: ExtractPayload<Mutations[MutationName]> | ((storeModule: WirePayloadParams<ModuleName>) => ExtractPayload<Mutations[MutationName]>)): AnyWire;
    wireCommit<Mutations extends ExtractMutations<XModulesTree[ModuleName]>, MutationName extends PropsWithType<Mutations, (payload: any) => void>>(mutation: MutationName): Wire<ExtractPayload<Mutations[MutationName]>>;
    wireCommitWithoutPayload<Mutations extends ExtractMutations<XModulesTree[ModuleName]>, MutationName extends PropsWithType<Mutations, () => void>>(mutation: MutationName): AnyWire;
    wireDispatch<Actions extends ExtractActions<XModulesTree[ModuleName]>, ActionName extends PropsWithType<Actions, (payload: any) => void>>(action: ActionName, staticPayload: ExtractPayload<Actions[ActionName]>): AnyWire;
    wireDispatch<Actions extends ExtractActions<XModulesTree[ModuleName]>, ActionName extends PropsWithType<Actions, (payload: any) => void>>(action: ActionName): Wire<ExtractPayload<Actions[ActionName]>>;
    wireDispatchWithoutPayload<Actions extends ExtractActions<XModulesTree[ModuleName]>, ActionName extends PropsWithType<Actions, () => void>>(action: ActionName): AnyWire;
}

// @public
export class NextQueries extends Vue {
    protected emitNextQuerySelected(nextQuery: NextQuery): void;
    // Warning: (ae-forgotten-export) The symbol "NextQuery" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    nextQueries: NextQuery[];
}

// @public
export interface NextQueriesActions {
    getAndSaveNextQueries(): void;
    getNextQueries(): NextQuery[];
    setQueryFromLastHistoryQuery(historyQueries: HistoryQuery_2[]): void;
}

// @public
export interface NextQueriesConfig {
    hideSessionQueries: boolean;
    itemsToRequest: number;
    loadOnInit: boolean;
}

// @internal
export const nextQueriesEmitters: {
    NextQueriesChanged: (state: import("./types").NextQueriesState) => import("@empathy/search-types").NextQuery[];
    NextQueriesRequestChanged: (_: import("./types").NextQueriesState, getters: import("../../..").Returns<import("../../../store").GettersTree<import("./types").NextQueriesState, import("./types").NextQueriesGetters>>) => import("@empathy/search-adapter").NextQueriesRequest | null;
};

// @public
export interface NextQueriesGetters {
    nextQueries: NextQuery[];
    request: NextQueriesRequest | null;
}

// @public
export const nextQueriesModule: import("../..").NamespacedWireFactory<"nextQueries">;

// @public
export interface NextQueriesMutations {
    setNextQueries(nextQueries: NextQuery[]): void;
    setQuery(newQuery: string): void;
    setSearchedQueries(searchedQueries: HistoryQuery_2[]): void;
}

// @public
export interface NextQueriesState {
    config: NextQueriesConfig;
    nextQueries: NextQuery[];
    query: string;
    searchedQueries: HistoryQuery_2[];
}

// @internal
export const nextQueriesWiring: {
    UserAcceptedAQuery: {
        setNextQueriesQuery: import("../..").Wire<string>;
    };
    SessionHistoryQueriesChanged: {
        setSearchedQueries: import("../..").Wire<import("@empathy/search-types").HistoryQuery[]>;
        setQueryFromLastHistoryQuery: import("../..").Wire<import("@empathy/search-types").HistoryQuery[]>;
    };
    NextQueriesRequestChanged: {
        getAndSaveNextQueries: import("../..").Wire<any>;
    };
};

// @public
export type NextQueriesXModule = XModule<NextQueriesXStoreModule>;

// @public
export const nextQueriesXModule: NextQueriesXModule;

// @public
export type NextQueriesXStoreModule = XStoreModule<NextQueriesState, NextQueriesGetters, NextQueriesMutations, NextQueriesActions>;

// @internal
export const nextQueriesXStoreModule: NextQueriesXStoreModule;

// @public
export function normalizeString(string: string | undefined): string;

// @public
export type Pair<Type> = [Type, Type];

// @public
export class PopularSearch extends Vue {
    protected get events(): Partial<XEventsTypes>;
    // Warning: (ae-forgotten-export) The symbol "Suggestion" needs to be exported by the entry point index.d.ts
    protected suggestion: Suggestion;
}

// @public
export class PopularSearches extends Vue {
    // (undocumented)
    suggestions: Suggestion[];
}

// @public
export interface PopularSearchesActions {
    getAndSaveSuggestions(): void;
    getSuggestions(): Suggestion[];
}

// @public
export interface PopularSearchesConfig {
    maxItemsToRender: number;
    showExtraSuggestionWithoutFilter: boolean;
}

// @internal
export const popularSearchesEmitters: {
    PopularSearchesRequestChanged: {
        selector: (_: import("./types").PopularSearchesState, getters: import("../../..").Returns<import("../../..").GettersTree<import("./types").PopularSearchesState, import("./types").PopularSearchesGetters>>) => import("@empathy/search-adapter").SuggestionsRequest;
        immediate: true;
    };
};

// @public
export interface PopularSearchesGetters {
    request: SuggestionsRequest;
}

// @public
export interface PopularSearchesMutations {
    setSuggestions(suggestions: Suggestion[]): void;
}

// @public
export interface PopularSearchesState {
    config: PopularSearchesConfig;
    popularSearches: Suggestion[];
}

// @internal
export const popularSearchesWiring: {
    PopularSearchesRequestChanged: {
        retrievePopularSuggestions: import("../..").Wire<any>;
    };
};

// @public
export type PopularSearchesXModule = XModule<PopularSearchesXStoreModule>;

// @public
export const popularSearchesXModule: PopularSearchesXModule;

// @public
export type PopularSearchesXStoreModule = XStoreModule<PopularSearchesState, PopularSearchesGetters, PopularSearchesMutations, PopularSearchesActions>;

// @internal
export const popularSearchesXStoreModule: PopularSearchesXStoreModule;

// @public
export type Primitive = string | number | boolean | undefined | null | symbol | AnyFunction;

// @public
export type PropsWithType<Type, PropType> = {
    [Key in keyof Type]: Type[Key] extends PropType ? Key : never;
}[keyof Type];

// @public
export class QuerySuggestion extends Vue_2 {
    // @internal
    protected event: Partial<XEventsTypes>;
    query: string;
    protected suggestion: Suggestion;
}

// @public
export class QuerySuggestions extends Vue {
    suggestions: Suggestion[];
}

// @public
export interface QuerySuggestionsActions {
    getAndSaveSuggestions(): void;
    getSuggestions(): Suggestion[];
}

// @public
export interface QuerySuggestionsConfig {
    debounceInMs: number;
    hideIfEqualsQuery: boolean;
    maxItemsToRequest: number;
    showExtraSuggestionWithoutFilter: boolean;
}

// @internal
export const querySuggestionsEmitters: {
    QuerySuggestionsChanged: (state: import("./types").QuerySuggestionsState) => import("@empathy/search-types").Suggestion[];
    QuerySuggestionsRequestChanged: (_: import("./types").QuerySuggestionsState, getters: import("../../..").Returns<import("../../../store").GettersTree<import("./types").QuerySuggestionsState, import("./types").QuerySuggestionsGetters>>) => import("@empathy/search-adapter").SuggestionsRequest | null;
};

// @public
export interface QuerySuggestionsGetters {
    normalizedQuery: string;
    request: SuggestionsRequest | null;
}

// @public
export const querySuggestionsModule: import("../..").NamespacedWireFactory<"querySuggestions">;

// @public
export interface QuerySuggestionsMutations {
    setQuery(newQuery: string): void;
    setSuggestions(suggestions: Suggestion[]): void;
}

// @public
export interface QuerySuggestionsState {
    config: QuerySuggestionsConfig;
    query: string;
    suggestions: Suggestion[];
}

// @internal
export const querySuggestionsWiring: {
    UserIsTypingAQuery: {
        setQuerySuggestionsQuery: import("../..").Wire<string>;
    };
    UserAcceptedAQuery: {
        setQuerySuggestionsQuery: import("../..").Wire<string>;
    };
    UserPressedClearSearchBoxButton: {
        clearQuerySuggestionsQuery: import("../..").Wire<any>;
    };
    QuerySuggestionsRequestChanged: {
        getAndSaveSuggestions: import("../..").Wire<any>;
    };
};

// @public
export type QuerySuggestionsXModule = XModule<QuerySuggestionsXStoreModule>;

// @public
export const querySuggestionsXModule: QuerySuggestionsXModule;

// @public
export type QuerySuggestionsXStoreModule = XStoreModule<QuerySuggestionsState, QuerySuggestionsGetters, QuerySuggestionsMutations, QuerySuggestionsActions>;

// @internal
export const querySuggestionsXStoreModule: QuerySuggestionsXStoreModule;

// @public
export function reduce<T extends Dictionary, V>(obj: T | undefined | null, reducer: (accumulator: V, key: keyof T, value: Exclude<T[keyof T], undefined>, index: number) => V, initialValue: V): V;

// @public
export const refreshHistoryQueriesSession: import("../..").Wire<any>;

// @public
export const refreshSession: HistoryQueriesXStoreModule['actions']['refreshSession'];

// @public
export const removeFromHistory: HistoryQueriesXStoreModule['actions']['removeFromHistory'];

// @public
export class RemoveHistoryQuery extends Vue {
    protected historyQuery: HistoryQuery_2;
    protected get removeHistoryQueryEvent(): Partial<XEventsTypes>;
}

// @public
export const removeHistoryQuery: import("../..").Wire<import("@empathy/search-types").HistoryQuery>;

// @public
export const removeHTMLTags: (str: string) => string;

// @public
export type Returns<T extends Dictionary<AnyFunction>> = {
    [K in keyof T]: ReturnType<T[K]>;
};

// @internal
export const RootXStoreModule: Module<XModuleState, any>;

// @public
export interface RootXStoreState {
    // (undocumented)
    x: {
        [Module in XModuleName]: ExtractState<Module>;
    };
}

// @public
export interface SearchBoxActions {
}

// @public
export interface SearchBoxConfig {
    autocomplete: {
        keyboardKeys: string[];
        suggestionsEvent: PropsWithType<XEventsTypes, Suggestion[]>;
    };
    autofocus: boolean;
    maxLength: number;
}

// @internal
export const searchBoxEmitters: {
    SearchBoxQueryChanged: (_: import("./types").SearchBoxState, getters: import("../../..").Returns<import("../../../store").GettersTree<import("./types").SearchBoxState, import("./types").SearchBoxGetters>>) => string;
};

// @public
export interface SearchBoxGetters {
    trimmedQuery: string;
}

// @public
export interface SearchBoxMutations {
    setQuery(newQuery: string): void;
}

// @public
export interface SearchBoxState {
    config: SearchBoxConfig;
    query: string;
}

// @internal
export const searchBoxWiring: {
    UserIsTypingAQuery: {
        setSearchBoxQuery: import("../..").Wire<string>;
    };
    UserAcceptedAQuery: {
        setSearchBoxQuery: import("../..").Wire<string>;
    };
    UserPressedClearSearchBoxButton: {
        clearSearchBoxQuery: import("../..").Wire<any>;
    };
};

// @public
export type SearchBoxXModule = XModule<SearchBoxXStoreModule>;

// @public
export const searchBoxXModule: SearchBoxXModule;

// @public
export type SearchBoxXStoreModule = XStoreModule<SearchBoxState, SearchBoxGetters, SearchBoxMutations, SearchBoxActions>;

// @internal
export const searchBoxXStoreModule: SearchBoxXStoreModule;

// @public
export class SearchButton extends Vue {
    // (undocumented)
    protected get dynamicClasses(): VueCSSClasses;
    // (undocumented)
    protected get events(): Partial<XEventsTypes>;
    // (undocumented)
    protected get isQueryEmpty(): boolean;
    // (undocumented)
    query: string;
}

// @public
export class SearchInput extends Vue {
    // (undocumented)
    $refs: {
        input: HTMLInputElement;
    };
    // @internal
    blurInput(): void;
    // (undocumented)
    config: SearchBoxConfig;
    // @internal
    protected emitUserBlurredSearchBox(): void;
    // @internal
    protected emitUserFocusedSearchBox(): void;
    // @internal
    protected emitUserIsTypingAQuery(): void;
    // @internal
    protected emitUserPressedArrowKey(event: KeyboardEvent): void;
    // @internal
    protected emitUserPressedEnterKey(): void;
    // @internal
    protected eventMetadata(): Omit<WireMetadata, 'moduleName'>;
    // @internal
    protected preventForbiddenCharacters(event: KeyboardEvent): void;
    // (undocumented)
    query: string;
}

// @public
export const sessionHistoryQueries: HistoryQueriesXStoreModule['getters']['sessionHistoryQueries'];

// @public
export const setHistoryQueries: HistoryQueriesXStoreModule['actions']['setHistoryQueries'];

// @public
export const setHistoryQueriesQuery: import("../..").Wire<string>;

// @public
export const setNextQueriesQuery: import("../..").Wire<string>;

// @public
export const setQueryFromLastHistoryQuery: import("../..").Wire<import("@empathy/search-types").HistoryQuery[]>;

// @public
export const setQuerySuggestionsQuery: import("../..").Wire<string>;

// @public
export const setSearchedQueries: import("../..").Wire<import("@empathy/search-types").HistoryQuery[]>;

// @internal
export function setXComponentXModuleName(component: Vue, name: XModuleName): void;

// @public
export type SimpleStateSelector<ReturnType, State extends Dictionary, Getters extends Dictionary> = (state: State, getters: Getters) => ReturnType;

// @public
export function State<Module extends XModuleName, Path extends keyof ExtractState<Module>>(module: Module, path: Path): DecoratorFor<ExtractState<Module>[Path]>;

// @public
export interface StateSelector<ReturnType, State extends Dictionary, Getters extends Dictionary> extends WatchOptions {
    // (undocumented)
    selector: SimpleStateSelector<ReturnType, State, Getters>;
}

// @public
export const storageKey: HistoryQueriesXStoreModule['getters']['storageKey'];

// @public
export type StoreEmitters<StoreModule extends AnyXStoreModule> = {
    [Event in XEvent]?: SimpleStateSelector<XEventPayload<Event>, ReturnType<StoreModule['state']>, Returns<StoreModule['getters']>> | StateSelector<XEventPayload<Event>, ReturnType<StoreModule['state']>, Returns<StoreModule['getters']>>;
};

// @public
export type VueCSSClasses = string | Dictionary<boolean> | (string | Dictionary<boolean>)[];

// @public
export type Wire<PayloadType> = (observable: Observable<WirePayload<PayloadType>>, store: Store<RootXStoreState>) => Subscription;

// @public
export function wireCommit(mutation: string, payloadFactory: (params: Pick<Store<RootXStoreState>, 'state' | 'getters'>) => any): AnyWire;

// @public
export function wireCommit(mutation: string, staticPayload: any): AnyWire;

// @public
export function wireCommit<Payload>(mutation: string): Wire<Payload>;

// @public
export function wireCommitWithoutPayload(mutation: string): AnyWire;

// @public
export function wireDispatch(action: string, staticPayload: any): AnyWire;

// @public
export function wireDispatch<Payload>(action: string): Wire<Payload>;

// @public
export function wireDispatchWithoutPayload(action: string): AnyWire;

// @public
export type WireForEvent<Event extends XEvent> = Wire<XEventPayload<Event>>;

// @public
export interface WireMetadata {
    moduleName: XModuleName | null;
    target?: HTMLElement;
}

// @public
export interface WireParams<Payload> extends WirePayload<Payload> {
    // (undocumented)
    store: Store<RootXStoreState>;
}

// @public
export interface WirePayload<PayloadType> {
    eventPayload: PayloadType;
    metadata: WireMetadata;
}

// @public
export interface WirePayloadParams<ModuleName extends XModuleName> {
    // (undocumented)
    getters: ExtractGetters<ModuleName>;
    // (undocumented)
    state: ExtractState<ModuleName>;
}

// @public
export type Wiring = {
    [E in XEvent]: Dictionary<WireForEvent<E>>;
};

// @public
export function withModule<ModuleName extends XModuleName>(moduleName: ModuleName): NamespacedWireFactory<ModuleName>;

// @public
export interface XActionContext<State extends Dictionary, Getters extends Dictionary, Mutations extends MutationsDictionary<Mutations>, Actions extends ActionsDictionary<Actions>> extends ActionContext<State, RootXStoreState> {
    // (undocumented)
    commit<MutationName extends PropsWithType<Mutations, () => void>>(mutation: MutationName): void;
    // (undocumented)
    commit<MutationName extends keyof Mutations>(mutation: MutationName, payload: ExtractPayload<Mutations[MutationName]>): void;
    // (undocumented)
    dispatch<ActionName extends PropsWithType<Actions, () => any>>(action: ActionName): ExtractActionReturn<Actions[ActionName]>;
    // (undocumented)
    dispatch<ActionName extends keyof Actions>(action: ActionName, payload: ExtractPayload<Actions[ActionName]>): ExtractActionReturn<Actions[ActionName]>;
    // (undocumented)
    getters: Getters;
}

// @public
export interface XBus {
    emit(event: PropsWithType<XEventsTypes, void>): void;
    emit<Event extends XEvent>(event: Event, payload: XEventPayload<Event>, metadata?: WireMetadata): void;
    on<Event extends XEvent>(event: Event, withMetadata: true): Observable<WirePayload<XEventPayload<Event>>>;
    on<Event extends XEvent>(event: Event, withMetadata?: false): Observable<XEventPayload<Event>>;
    on<Event extends XEvent>(event: Event, withMetadata: boolean): Observable<XEventPayload<Event> | WirePayload<XEventPayload<Event>>>;
}

// @public
export interface XComponent extends Vue {
    // @internal
    [XComponentModule]: XModuleName;
    setConfig?(configPropName: string, configPropValue: any): void;
}

// @public
export interface XComponentAPI extends Pick<XBus, 'on'> {
    config: XConfig;
    emit(event: PropsWithType<XEventsTypes, void>): void;
    emit<Event extends XEvent>(event: Event, payload: XEventPayload<Event>, metadata?: Omit<WireMetadata, 'moduleName'>): void;
}

// @public
export function xComponentMixin(module: AnyXModule, { configPropsNames }?: XComponentOptions): ComponentOptions<Vue> & ThisType<XComponent>;

// @internal
export const XComponentModule: unique symbol;

// @public
export interface XComponentOptions {
    configPropsNames?: string[];
}

// @public
export interface XConfig {
    consent: boolean;
    currencyOptions: CurrencyOptions;
    documentDirection: DocumentDirection;
    messages: Messages;
}

// @public
export type XEvent = keyof XEventsTypes;

// @public
export type XEventPayload<Event extends XEvent> = XEventsTypes[Event] extends void ? undefined : XEventsTypes[Event];

// @public
export interface XEventsTypes {
    AdapterConfigChanged: unknown;
    ConfigConsentChanged: boolean;
    ConfigCurrencyChanged: CurrencyOptions;
    ConfigDocumentDirectionChanged: DocumentDirection;
    HistoryQueriesDisplayed: HistoryQuery_2[];
    HistoryQueriesQueryChanged: string;
    HistoryQueriesStorageKeyChanged: string;
    NextQueriesChanged: NextQuery[];
    NextQueriesDisplayed: NextQuery[];
    NextQueriesRequestChanged: NextQueriesRequest | null;
    PopularSearchDisplayed: Suggestion[];
    PopularSearchesRequestChanged: SuggestionsRequest;
    QuerySuggestionsChanged: Suggestion[];
    QuerySuggestionsDisplayed: Suggestion[];
    QuerySuggestionsRequestChanged: SuggestionsRequest | null;
    SearchBoxQueryChanged: string;
    SessionHistoryQueriesChanged: HistoryQuery_2[];
    SuggestionsDisplayed: Suggestion[];
    UserAcceptedAQuery: string;
    UserBlurredSearchBox: void;
    UserFocusedSearchBox: void;
    UserIsTypingAQuery: string;
    UserPressedArrowKey: ArrowKey;
    UserPressedClearHistoryQueries: void;
    UserPressedClearSearchBoxButton: void;
    UserPressedEnterKey: string;
    UserPressedRemoveHistoryQuery: HistoryQuery_2;
    UserPressedSearchButton: string;
    UserSelectedAHistoryQuery: HistoryQuery_2;
    UserSelectedANextQuery: NextQuery;
    UserSelectedAPopularSearch: Suggestion;
    UserSelectedAQuerySuggestion: Suggestion;
    UserSelectedASuggestion: Suggestion;
    UserTalked: string;
}

// @public
export interface XModule<StoreModule extends AnyXStoreModule> {
    name: XModuleName;
    storeEmitters: StoreEmitters<StoreModule>;
    storeModule: StoreModule;
    wiring: Partial<Wiring>;
}

// @public
export type XModuleName = keyof XModulesTree;

// @public
export interface XModuleOptions<Module extends AnyXModule> {
    storeEmitters?: Partial<StoreEmitters<Module['storeModule']>>;
    storeModule?: XStoreModuleOptions<Module['storeModule']>;
    wiring?: Partial<Wiring>;
}

// @public
export type XModulesOptions = {
    [N in XModuleName]?: XModuleOptions<XModulesTree[N]>;
};

// @internal
export type XModuleState = {
    [Key in keyof RootXStoreState['x']]: null;
};

// @public
export interface XModulesTree {
    // (undocumented)
    historyQueries: HistoryQueriesXModule;
    // (undocumented)
    nextQueries: NextQueriesXModule;
    // (undocumented)
    popularSearches: PopularSearchesXModule;
    // (undocumented)
    querySuggestions: QuerySuggestionsXModule;
    // (undocumented)
    searchBox: SearchBoxXModule;
}

// @public
export function XOn<Event extends XEvent>(event: Event): DecoratorFor<(payload: XEventPayload<Event>) => void>;

// @public
export class XPlugin {
    // @internal
    protected constructor();
    static adapter: SearchAdapter;
    // @internal
    protected addConfigMutation(storeModule: Module<any, any>): Module<any, any>;
    // @internal
    protected applyMixins(): void;
    // @internal
    protected bus: import("./x-bus.types").XBus;
    // @internal
    protected createAdapterConfigChangedListener(adapter: SearchAdapter): void;
    // @internal
    protected customizeStoreModule({ state: getState, ...actionsGettersMutations }: AnyXStoreModule, { state: stateOptions, ...newActionsGettersMutations }: AnyXStoreModuleOptions): AnyXStoreModule;
    static getConfig(): XConfig;
    // @internal
    protected getDefaultSetConfigMutation(): (state: any, config: any) => void;
    // @internal
    protected getModuleOptions(name: XModuleName): XModuleOptions<AnyXModule> | undefined;
    // @internal
    protected hasModuleConfig(storeModule: Module<any, any>): boolean;
    // @internal
    static install(vue: VueConstructor, options?: XPluginOptions): void;
    // @internal
    protected installedXModules: Set<string>;
    // @internal
    protected static instance: XPlugin;
    // @internal
    protected isInstalled: boolean;
    // @internal
    protected isSimpleSelector(stateSelector: AnySimpleStateSelector | AnyStateSelector): stateSelector is AnySimpleStateSelector;
    // @internal
    protected lazyRegisterXModule(xModule: AnyXModule): void;
    // @internal
    protected options: XPluginOptions;
    // @internal
    protected pendingXModules: Partial<Record<XModuleName, AnyXModule>>;
    // @internal
    protected registerConfig(): void;
    // @internal
    protected registerPendingXModules(): void;
    // @internal
    protected registerStore(): void;
    // @internal
    protected registerStoreEmitters(name: XModuleName, storeModule: AnyXStoreModule, storeEmitters: AnyStoreEmitters): void;
    // @internal
    protected registerStoreModule(name: XModuleName, storeModule: AnyXStoreModule): void;
    // @internal
    protected registerWiring(name: XModuleName, wiring: Partial<Wiring>): void;
    static registerXModule(xModule: AnyXModule): void;
    // @internal
    protected registerXModule({ name, wiring, storeModule, storeEmitters }: AnyXModule): void;
    static setConfig(config: DeepPartial<XConfig>): void;
    // @internal
    protected store: Store<any>;
    // @internal
    protected vue: VueConstructor;
    // @internal
    protected xConfig: XConfig;
}

// @public
export interface XPluginOptions {
    adapter: SearchAdapter;
    config?: XConfig;
    store?: Store<any>;
    xModules?: XModulesOptions;
}

// @public
export interface XStoreModule<State extends Record<keyof State, any>, Getters extends Record<keyof Getters, any>, Mutations extends MutationsDictionary<Mutations>, Actions extends ActionsDictionary<Actions>> {
    // (undocumented)
    actions: ActionsTree<State, Getters, Mutations, Actions>;
    // (undocumented)
    getters: GettersTree<State, Getters>;
    // (undocumented)
    mutations: MutationsTree<State, Mutations>;
    // (undocumented)
    state: () => State;
}

// @public
export type XStoreModuleOptions<StoreModule extends AnyXStoreModule> = StoreModule extends XStoreModule<infer State, infer Getters, infer Mutations, infer Actions> ? {
    state?: DeepPartial<State> & Dictionary;
    actions?: DeepPartial<ActionsTree<State, Getters, Mutations, Actions>> & AnyActionsTree;
    getters?: DeepPartial<GettersTree<State, Getters>> & AnyGettersTree;
    mutations?: DeepPartial<MutationsTree<State, Mutations>> & AnyMutationsTree;
} : never;


// (No @packageDocumentation comment for this package)

```
